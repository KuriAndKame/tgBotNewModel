import edge_tts
import asyncio
import os
import time
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import News, Articles
from datetime import datetime

# Настройки
voices = {
    "female": "ru-RU-SvetlanaNeural",
    "male": "ru-RU-DmitryNeural"
}
output_folder = "audio_files"
processed_items = set()
processed_items_path = "processed/processed_items.txt"  # Новый путь к файлу

# Настройки базы данных
DATABASE_URL = "sqlite:///your_database.db"
engine = create_engine(DATABASE_URL)
Session = sessionmaker(bind=engine)

# Создаем необходимые папки
os.makedirs(output_folder, exist_ok=True)
os.makedirs(os.path.dirname(processed_items_path), exist_ok=True)  # Создаем папку для processed_items.txt

def load_already_processed_items():
    """Загружаем список уже обработанных записей из указанного пути"""
    if os.path.exists(processed_items_path):
        with open(processed_items_path, 'r', encoding='utf-8') as f:
            for line in f:
                processed_items.add(line.strip())

def save_processed_items():
    """Сохраняем список обработанных записей по указанному пути"""
    with open(processed_items_path, 'w', encoding='utf-8') as f:
        for item_id in processed_items:
            f.write(item_id + '\n')

async def generate_speech(text, output_file):
    try:
        tts = edge_tts.Communicate(text=text, voice=voice)
        await tts.save(output_file)
    except Exception as e:
        print(f"Ошибка при генерации речи: {e}")

def process_item(item, table_name):
    try:
        item_id = f"{table_name}:{item.id}"
        if item_id in processed_items:
            return
            
        text = item.refactoredText
        title = item.refactoredTitle
        
        if not text or not text.strip():
            print(f"Запись {item_id} пуста, пропускаем.")
            return
            
        # Создаем имя файла из refactoredTitle (с заменой недопустимых символов)
        safe_title = "".join(c if c.isalnum() or c in " _-" else "_" for c in title)
        output_file = os.path.join(output_folder, f"{safe_title}_{table_name}.mp3")
        
        # Генерируем речь
        asyncio.run(generate_speech(text, output_file))
        
        # Добавляем запись в обработанные
        processed_items.add(item_id)
        print(f"Обработана запись {item_id} -> {output_file}")
        
    except Exception as e:
        print(f"Ошибка при обработке записи {item_id}: {e}")

def monitor_database():
    """Мониторим базу данных на наличие новых записей в обеих таблицах"""
    print("Мониторинг базы данных начат...")
    load_already_processed_items()
    
    try:
        while True:
            session = Session()
            try:
                # Обрабатываем таблицу News
                news_items = session.query(News).filter(
                    News.refactoredText.isnot(None),
                    News.refactoredTitle.isnot(None)
                ).all()
                
                for item in news_items:
                    process_item(item, "news")
                
                # Обрабатываем таблицу Articles
                articles_items = session.query(Articles).filter(
                    Articles.refactoredText.isnot(None),
                    Articles.refactoredTitle.isnot(None)
                ).all()
                
                for item in articles_items:
                    process_item(item, "articles")
                
                session.commit()
            except Exception as e:
                session.rollback()
                print(f"Ошибка при работе с базой данных: {e}")
            finally:
                session.close()
            
            time.sleep(60)  # Проверяем каждую минуту
    except KeyboardInterrupt:
        save_processed_items()
        print("Мониторинг остановлен.")

if __name__ == "__main__":
    monitor_database()
